  <!DOCTYPE html>
  <html lang="nl">
  <head>
  <meta charset="UTF-8">
  <title>Circuit Racer V1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<style>
body {
    margin:0;
    background:#111;
    color:white;
    font-family:monospace;
    display:flex;
    flex-direction:column;
    align-items:center;
    touch-action: none;
}

html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
}


h2 { display: none !important; }
/* ===== TOP BAR (NEEMT RUIMTE IN, LIGT NIET OVER CANVAS) ===== */
#topBar {
    width: 100%;
    height: 48px;
    background: rgba(0,0,0,0.85);
    border-bottom: 2px solid #333;
    display: flex;
    justify-content: center; /* ðŸ‘ˆ alles in het midden */
    align-items: center;
    box-sizing: border-box;
}


#centerBar {
    display: flex;
    align-items: center;
    gap: 20px;              /* ruimte tussen laps | scoreboard | hud */
}



/* laps links */
#lapContainer input {
    width: 50px;
}

/* HUD gecentreerd */

#hud {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-size: 14px;
    white-space: nowrap;
}

/* ===== GAME AREA ===== */


canvas#game {
    max-width: 100%;
    max-height: 100%;
    image-rendering: pixelated;
}

#mobileControls {
    position: fixed;
    bottom: 5px;
    left: 0;
    right: 0;
    height: 35%;
    pointer-events: auto;
    display: flex;
    justify-content: space-between;
    padding: 0 15px;
    box-sizing: border-box;
    z-index: 12;
}

.stick {
    position: relative;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.12);
    pointer-events: auto;
    touch-action: none;
}

#stickP1 { margin-left: 10px; }
#stickP2 { margin-right: 10px; }

.knob {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.7);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}


#minigameOverlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: none;
    pointer-events: none;
    z-index: 25;
}


.minigamePanel {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: rgba(0,0,0,0.75);
    border: 2px solid white;
    padding: 6px;
    pointer-events: auto;
    min-width: 20px;
    min-height: 80px;
    width: 100%; /* default */
    height: auto; /* default */
    max-height: 80%;
    display: none;
    box-sizing: border-box;
}


#scoreboardButtonContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 10px; /* beetje ruimte tussen lap counter en HUD */
}

.scoreboardButton {
    display: inline-block;
    padding: 8px 15px;
    font-size: 1.2rem; /* kleiner dan game-knop, past beter */
    font-weight: bold;
    color: #ffcc00;             /* gele letters */
    background-color: red;  /* rood */
    border: 2px solid #ffff66;
    border-radius: 8px;
    text-decoration: none;
    box-shadow: 0 0 15px #ffff66;
    transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;w
}

.playerRow {
    display: flex;
    align-items: center;
    gap: 6px;
}

.playerRow label {
    width: 28px;
    text-align: right;
}

.playerRow input {
    width: 60px;
}


.stats {
    min-width: 420px;
    font-family: monospace;
}


.scoreboardButton:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px #ffff66;
    background-color: green; /* groen bij hover */
}

  .scoreboardButton:active {
    transform: scale(1.1);
    box-shadow: 0 0 20px #ffff66;
    background-color: green; /* groen bij hover */
}

/* Responsive tweaks */
@media(max-width:900px){
  .scoreboardButton {
    font-size: 1rem;
    padding: 6px 12px;
  }
}


/* Overlay einde spel */
#overlay {
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:rgba(0,0,0,0.85);
    color:white;
    font-size:48px;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    z-index:30;
    gap:20px;
}
#gameWrapper {
    position: relative;
    width: 100%;
    height: calc(100vh - 48px);
    max-height: calc(100vh - 48px);

    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

#game {
    max-width: 100%;
    max-height: 100%;
    image-rendering: pixelated;
}

#newGameBtn {
    font-size:24px;
    padding:10px 20px;
    cursor:pointer;
}

/* DEFAULT (desktop) */
/* topbar zichtbaar */
/* canvas in layout */
/* geen overlay joysticks */



@media (max-width: 900px) and (orientation: landscape) {
  #mobileControls {
    display: block;
    position: fixed;
    bottom: 0; /* Stick container onderaan */
    left: 0;
    right: 0;
    height: 30%; /* of wat past */
    pointer-events: none;
    z-index: 20;
  }

  .stick {
    position: absolute;
    bottom: 5%; /* afstand vanaf container bottom */
    width: 120px;
    height: 120px;
    opacity: 0.6;
    pointer-events: auto;
  }

  #stickP1 { left: 5%; }
  #stickP2 { right: 5%; }
}







@media (max-width: 600px) and (orientation: landscape) {

  .stick {
    width: 120px;
    height: 120px;
  }

  #topBar {
    font-size: 11px;
  }
}


@media (min-width: 900px) and (max-width: 1200px) {
  /* tablet fine-tuning */
}


</style>


  </head>
<body>

<div id="boostControls" style="position:fixed;bottom:10%;width:100%;display:flex;justify-content:space-between;pointer-events:auto;z-index:15;">
  <button id="boostP1" style="padding:20px;font-size:20px;">BOOST</button>
  <button id="boostP2" style="padding:20px;font-size:20px;">BOOST</button>
</div>



<div id="trackMenu" style="position:fixed;top:0;left:0;right:0;bottom:0;
     background:rgba(0,0,0,0.9);color:white;display:flex;flex-direction:column;
     justify-content:center;align-items:center;gap:20px;z-index:50;">
  <h1>Select Track</h1>
  <button onclick="selectTrack('LVL1')">Track 1</button>
  <button onclick="selectTrack('LVL2')">Track 2</button>
</div>


<div id="rotateWarning" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0;
     background:rgba(0,0,0,0.9); color:white; font-size:24px;
     justify-content:center; align-items:center; text-align:center; z-index:50;">
    TURN YOUR PHONE TO PLAY THE GAME!
</div>


<div id="topBar">
  <div id="lapContainer">
    Laps:
    <input id="lapInput" type="number" value="3" min="3">
  </div>

  <a href="https://blackeagle8100.github.io/RacingBoard/" target="_blank" class="scoreboardButton">
    SCOREBOARD!
  </a>Â²

  <div id="hud">
    <div class="playerRow">
      <label for="nameP1">P1:</label>
      <input type="text" id="nameP1" value="P1">
      <span id="statsP1" class="stats"></span>
    </div>

    <div class="playerRow">
      <label for="nameP2">P2:</label>
      <input type="text" id="nameP2" value="P2">
      <span id="statsP2" class="stats"></span>
    </div>
  </div>
</div>



<div id="gameWrapper">
  <canvas id="game"></canvas>
</div>




    <div id="minigameOverlay">
      <div id="panelP1" class="minigamePanel">
        <div>Player 1</div>
        <canvas id="minigameCanvas1" width="300" height="150"></canvas>
        <div id="minigameStatus1"></div>
      </div>

      <div id="panelP2" class="minigamePanel">
        <div>Player 2</div>
        <canvas id="minigameCanvas2" width="300" height="150"></canvas>
        <div id="minigameStatus2"></div>
      </div>
    </div>

    <div id="overlay" style="display:none">
      <span id="winnerText">WINNER</span>
      <button id="newGameBtn">NEW GAME</button>
    </div>


  <div id="mobileControls">
    <div id="stickP1" class="stick"><div class="knob"></div></div>
    <div id="stickP2" class="stick"><div class="knob"></div></div>
  </div>




  <script>



  // Supabase client initialiseren
    // === Spelers ===
  const players = {
    P1: {
      lane:"1", x:0,y:0,color:"cyan",
      angle: 0,
      keys:{
        z:[0,-1], s:[0,1], q:[-1,0], d:[1,0],      // AZERTY
        arrowup:[0,-1], arrowdown:[0,1],           // pijltjes
        arrowleft:[-1,0], arrowright:[1,0]
      },
      started:false, lap:0, lapStart:0,
      totalTime:0, bestLap:null,
      lastTile:null, nextCheckpoint:0,
      inMinigame:false,
      finishTime: null
    },
    P2: {
      lane:"2", x:0,y:0,color:"yellow",
      angle: 0,
      keys:{
        i:[0,-1], k:[0,1], j:[-1,0], l:[1,0],       // letters
        "8":[0,-1], "5":[0,1], "4":[-1,0], "6":[1,0] // NUMPAD (NumLock)
      },

      started:false, lap:0, lapStart:0,
      totalTime:0, bestLap:null,
      lastTile:null, nextCheckpoint:0,
      inMinigame:false,
      finishTime: null
    }
  }
  let currentTrack = null;
  let track = null;
    // Minigame instellingen
  // === MINIGAME SETTINGS ===
  // Map van trigger tiles naar minigames


  // === MINIGAME SETTINGS ===
  const BALANCE_DURATION = 3; // seconden dat de speler moet balanceren
  let GLOBAL_PLANK_LENGTH = green.width * scaleX * 0.35;
  GLOBAL_PLANK_LENGTH = Math.max(160, Math.min(GLOBAL_PLANK_LENGTH, 260));

 // let PLANK_LENGTH = 300;  // pixels
  const MAX_ANGLE = 35;       // max kanteling
  const BALANCE_ZONE = 30;    // px rond midden waar het groen is   // pixels/sec^2
  const GRAVITY = 420;
  const FRICTION = 0.995;
  const BASE_PLANK = 220; // ðŸ‘ˆ HIER

  const checkpoints = { "1": [], "2": [] };
  const used = new Set();
  const boosts = { P1: false, P2: false };


  document.getElementById("boostP1").addEventListener("mousedown",()=>boosts.P1=true);
  document.getElementById("boostP1").addEventListener("mouseup",()=>boosts.P1=false);
  document.getElementById("boostP2").addEventListener("mousedown",()=>boosts.P2=true);
  document.getElementById("boostP2").addEventListener("mouseup",()=>boosts.P2=false);

  // KEYMAPPING
  // PC toetsen
  window.addEventListener("keydown", e=>{
      if(e.key===" ") boosts.P1=true; // spatie = boost
  });
  window.addEventListener("keyup", e=>{
      if(e.key===" ") boosts.P1=false;
  });


 const minigameKeys = {
  P1: {
    left: ["q", "arrowleft"],
    right: ["d", "arrowright"]
  },
  P2: {
    left: ["j", "4"],
    right: ["l", "6"]
  }
};

  const minigameOverlay = document.getElementById("minigameOverlay");

  const mgCanvases = {
    P1: document.getElementById("minigameCanvas1"),
    P2: document.getElementById("minigameCanvas2")
  };
  const mgCtxs = {
    P1: mgCanvases.P1.getContext("2d"),
    P2: mgCanvases.P2.getContext("2d")
  };
  const mgStatus = {
    P1: document.getElementById("minigameStatus1"),
    P2: document.getElementById("minigameStatus2")
  };

  // Track minigame state per speler
  const minigameState = {
  P1: {
    active:false,
    type:null,
    plankAngle:0,
    ballX:0,
    ballSpeed:0,
    balanceTime:0,
    angle:0,
    speed:0,
    completed:false,
    lastTime:0
  },
  P2: {
    active:false,
    type:null,
    plankAngle:0,
    ballX:0,
    ballSpeed:0,
    balanceTime:0,
    angle:0,
    speed:0,
    completed:false,
    lastTime:0
  }
};

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

  //GAMESETTINGS
  const TILE_SIZE = 16;

  const SPEED = 400;
  document.getElementById("newGameBtn").addEventListener("click", () => {
    location.reload();
  });



  const LVL1 = [
  "**||*||**||**||**||**||**||**||**||**||**||**||**||**",
  "*11111C111111111NNNNNY222>BBBBBOBBBBB<22222C22222222*",
  "|11111C111111111NNNNNY222>BBBBBOBBBBB<22222C22222222|",
  "|11=============NNNN==============================22|",
  "*11=22C222222222NNNNNH111>BBBBBOBBBBB<11111C11111=22*",
  "*11=22C222222222NNNNNH111>BBBBBOBBBBB<11111C11111=22*",
  "|11=22||**||**||**||**||**||**||**||**||**||***11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*%%=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=%%*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*%%=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=%%*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22***||**||**||**||**||**||**||**||**||**||SS=SS|",
  "*11=222222C222222222222222222YNNNNN1111111111C111=22*",
  "*11=222222C222222222222222222YNNNNN1111111111C111=22*",
  "|11============================NNNN===============22|",
  "|111111111C111111111111111111HNNNNN2222222222C222222|",
  "*111111111C111111111111111111HNNNNN2222222222C222222*",
  "**||**||**||**||**||**||**||**||**||**||**||**||*||**"
  ];


  const LVL2 = [
  "**||*||**||**||**||**||**||**||**||**||**||**||**||**",
  "*11111C111111111NNNNNY222>LIIIIIIIIIL<22222C22222222*",
  "|11111C111111111NNNNNY222>LIIIIIIIIIL<22222C22222222|",
  "|11=============NNNN==============================22|",
  "*11=22C222222222NNNNNH111>LIIIIIIIIIL<11111C11111=22*",
  "*11=22C222222222NNNNNH111>LIIIIIIIIIL<11111C11111=22*",
  "|11=22||**||**||**||**||**||**||**||**||**||***11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*%%=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=%%*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*%%=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=%%*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22***||**||**||**||**||**||**||**||**||**||SS=SS|",
  "*11=222222C222222222222222222YNNNNN1111111111C111=22*",
  "*11=222222C222222222222222222YNNNNN1111111111C111=22*",
  "|11============================NNNN===============22|",
  "|111111111C111111111111111111HNNNNN2222222222C222222|",
  "*111111111C111111111111111111HNNNNN2222222222C222222*",
  "**||**||**||**||**||**||**||**||**||**||**||**||*||**"
  ];


   const tracks = {
  LVL1: { map: LVL1, minigame: "balance" },
  LVL2: { map: LVL2, minigame: "loop" }
  };
      // === CAR SPRITES ===
  const carSprites = {
    P1: new Image(),
    P2: new Image()
  };

  carSprites.P1.src = "icons/P1.png";
  carSprites.P2.src = "icons/P2.png";

  // (optioneel debug)
  carSprites.P1.onload = () => console.log("P1 car loaded");
  carSprites.P2.onload = () => console.log("P2 car loaded");


  let gameOver = false;
  let currentTable = "LVL1";

function positionMinigamePanel(pName) {
    const panel = document.getElementById(pName === "P1" ? "panelP1" : "panelP2");
    if (!panel) return;

    const wrapper = document.getElementById("gameWrapper");
    const rect = wrapper.getBoundingClientRect();
    // Plaats boven de canvas (bijvoorbeeld)
    panel.style.left = "50%";
    panel.style.top = "50%";
    panel.style.transform = "translate(-50%, -50%)";
}


function initTrackData() {
    // Maak arrays leeg voor beide lanes
    checkpoints["1"].length = 0;
    checkpoints["2"].length = 0;

    // Loop door de track
    for (let y = 0; y < track.length; y++) {
        for (let x = 0; x < track[y].length; x++) {
            const t = track[y][x];

            // Check voor checkpoints
            if (t === "C") {
                // Voeg toe aan beide lanes, of filter per lane indien nodig
                // Hier ga ik ervan uit dat lane 1 op '1' tiles start, lane 2 op '2'
                // Later sorteer je ze in selectTrack()
                checkpoints["1"].push({ x, y });
                checkpoints["2"].push({ x, y });
            }
        }
    }

    // Optioneel: sorteer de checkpoints rond het midden van de track
    const trackCenter = { x: track[0].length / 2, y: track.length / 2 };

    for (const lane of ["1", "2"]) {
        checkpoints[lane].sort((a, b) => {
            return Math.atan2(a.y - trackCenter.y, a.x - trackCenter.x)
                 - Math.atan2(b.y - trackCenter.y, b.x - trackCenter.x);
        });
    }

    console.log("Checkpoints initialized:", checkpoints);
}






function selectTrack(name){

        used.clear();
    checkpoints["1"].length = 0;
    checkpoints["2"].length = 0;

    currentTrack = tracks[name];
    track = currentTrack.map;
    currentTable = name;

    document.getElementById("trackMenu").style.display = "none";

    initTrackData();   // â† bouwt checkpoints[]
    findStart();
    resizeCanvas();
    checkOrientation();


    // âœ… HIER PLAATS JE DE CODE
    const trackCenter = {
        x: track[0].length / 2,
        y: track.length / 2
    };

    for (const lane of ["1", "2"]) {
        checkpoints[lane].sort((a, b) => {
            const ca = checkpointCenter(a);
            const cb = checkpointCenter(b);
            return Math.atan2(ca.y - trackCenter.y, ca.x - trackCenter.x)
                 - Math.atan2(cb.y - trackCenter.y, cb.x - trackCenter.x);
        });

        while (true) {
            const c = checkpointCenter(checkpoints[lane][0]);
            if (c.x > trackCenter.x && c.y > trackCenter.y) break;
            checkpoints[lane].push(checkpoints[lane].shift());
        }
    }

    lastTime = performance.now();
    requestAnimationFrame(loop);
}






function resizeMinigameCanvas(p){
    const panel = document.getElementById(p === "P1" ? "panelP1" : "panelP2");
    const canvas = mgCanvases[p];

    canvas.width  = panel.clientWidth - 12;
    canvas.height = panel.clientHeight - 20;


    // ðŸ”‘ eerlijk schalen op basis van groen veld
    const green = findGreenFieldBounds();
    const scaleX = document.getElementById("game").getBoundingClientRect().width / document.getElementById("game").width;

    //GLOBAL_PLANK_LENGTH = green.width * scaleX * 0.35;

    // safety clamp (extreme schermen)
    GLOBAL_PLANK_LENGTH = Math.max(160, Math.min(GLOBAL_PLANK_LENGTH, 260));
}



// âœ… Detect mobile / touch devices reliably
const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0)
                 && window.innerWidth <= 900;





function checkOrientation() {
    const warning = document.getElementById("rotateWarning");
    const gameWrapper = document.getElementById("gameWrapper");
    const mobileControls = document.getElementById("mobileControls");

    if (isMobile && window.innerHeight > window.innerWidth) {
        warning.style.display = "flex";
        gameWrapper.style.display = "none";
        mobileControls.style.display = "none";
    } else {
        warning.style.display = "none";
        gameWrapper.style.display = "flex";
        mobileControls.style.display = isMobile ? "flex" : "none";
        resizeCanvas();  // ðŸ”‘ ensure minigames scale correctly
    }
}


function resizeCanvas() {
    if (!track) return; // veiligheid: track moet geladen zijn

    // 1ï¸âƒ£ Bereken de echte canvas grootte op basis van tiles
    const gameWidth  = track[0].length * TILE_SIZE;
    const gameHeight = track.length * TILE_SIZE;

    canvas.width  = gameWidth;
    canvas.height = gameHeight;

    // 2ï¸âƒ£ Bereken schaal zodat het past in het wrapper-element
    const wrapper = document.getElementById("gameWrapper");
    const vw = window.innerWidth;
    const vh = wrapper.clientHeight;

    const scale = Math.min(vw / gameWidth, vh / gameHeight);

    canvas.style.width  = (gameWidth  * scale) + "px";
    canvas.style.height = (gameHeight * scale) + "px";

    // 3ï¸âƒ£ Update minigame plank-grootte op basis van green field
    const green = findGreenFieldBounds(); // bounds van 'G'-tiles
    const scaleX = canvas.getBoundingClientRect().width / canvas.width;
    GLOBAL_PLANK_LENGTH = green.width * scaleX * 0.35;

    // 4ï¸âƒ£ Clamp lengte zodat het niet te klein of groot wordt
    GLOBAL_PLANK_LENGTH = Math.max(160, Math.min(GLOBAL_PLANK_LENGTH, 260));

    // 5ï¸âƒ£ Update minigame panels (positie & grootte)
    positionMinigamePanel("P1");
    positionMinigamePanel("P2");
}



 window.addEventListener("resize", checkOrientation);
 window.addEventListener("orientationchange", checkOrientation);





  function tileAt(tx, ty){ return track[ty]?.[tx] || "|"; }


    // Start minigame voor speler p (P1 of P2)


function startMinigame(pName, tile) {
    if(players[pName].inMinigame) return;

    const minigamesToStart = [];

    // Bepaal welke minigame(s) we moeten starten op basis van tile
    switch(tile){
        case ">B": // Balance
            minigamesToStart.push("balance");
            break;
        case ">L": // Looping
            minigamesToStart.push("looping");
            break;
        case ">J": // Jump
            minigamesToStart.push("jump");
            break;
        default:
            console.warn("Onbekende minigame tile:", tile);
            return;
    }

    // âœ… Set speler in minigame
    players[pName].inMinigame = true;
    minigameOverlay.style.display = "block";

    // âœ… Start minigames Ã©Ã©n voor Ã©Ã©n
    runMinigamesSequence(pName, minigamesToStart);
}


function runMinigamesSequence(pName, sequence) {
    if(sequence.length === 0){
        // Alle minigames voltooid
        players[pName].inMinigame = false;
        checkMinigameOverlay();
        return;
    }

    const current = sequence.shift(); // eerste minigame
    switch(current){
        case "balance":
            startBalanceMinigame(pName, () => runMinigamesSequence(pName, sequence));
            break;
        case "looping":
            startLoopingMinigame(pName, () => runMinigamesSequence(pName, sequence));
            break;
        case "jump":
            startJumpMinigame(pName, () => runMinigamesSequence(pName, sequence));
            break;
    }
}

    // Set speler in minigame
    players[pName].inMinigame = true;
    minigameOverlay.style.display = "block";

    // Start minigames Ã©Ã©n voor Ã©Ã©n
    runMinigamesSequence(pName, minigamesToStart);





function startLoopingMinigame(pName){
    boosts[pName] = false;
    const state = minigameState[pName];
    if(state.active) return;

    state.active = true;
    state.type = "loop";

    updateMinigameOverlay();

    state.angle = -90;      // onderaan looping
    state.speed = 0;
    state.completed = false;
    state.lastTime = performance.now();

    players[pName].inMinigame = true;

    const panel = document.getElementById(
        pName === "P1" ? "panelP1" : "panelP2"
    );

    panel.style.display = "flex";
    panel.style.pointerEvents = "auto";

    positionMinigamePanel(pName);

    requestAnimationFrame(() => animateLoopingMinigame(pName));

}




function startJumpMinigame(pName, callback){
    const state = minigameState[pName];
    if(state.active) return;

    state.active = true;
    state.plankAngle = 0;
    state.ballX = -GLOBAL_PLANK_LENGTH/2 + 10;
    state.ballSpeed = 0;
    state.balanceTime = 0;
    state.completed = false;
    state.lastTime = performance.now();

    const panel = document.getElementById(pName === "P1" ? "panelP1" : "panelP2");
    panel.style.display = "flex";
    positionMinigamePanel(pName);

    // Animatie loop
    function anim(){
        if(!state.active){
            panel.style.display = "none";
            players[pName].inMinigame = false;
            if(callback) callback(); // ga naar volgende minigame
            return;
        }
        animateMinigame(pName);
        requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
}




function startBalanceMinigame(pName, callback){
    const state = minigameState[pName];
    if(state.active) return;

    state.active = true;
    state.plankAngle = 0;
    state.ballX = -GLOBAL_PLANK_LENGTH/2 + 10;
    state.ballSpeed = 0;
    state.balanceTime = 0;
    state.completed = false;
    state.lastTime = performance.now();

    const panel = document.getElementById(pName === "P1" ? "panelP1" : "panelP2");
    panel.style.display = "flex";
    positionMinigamePanel(pName);

    // Animatie loop
    function anim(){
        if(!state.active){
            panel.style.display = "none";
            players[pName].inMinigame = false;
            if(callback) callback(); // ga naar volgende minigame
            return;
        }
        animateMinigame(pName);
        requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
}







function checkMinigameOverlay(){
    if(!minigameState.P1.active && !minigameState.P2.active){
        minigameOverlay.style.display = "none";
    }
}

  // Minigame animatie per speler


  // MINIGAME LOOPING


  function animateLoopingMinigame(pName){
    const canvas = mgCanvases[pName];
    const ctx = canvas.getContext("2d");
    const state = minigameState[pName];

    const now = performance.now();
    const dt = Math.min(0.05, (now - state.lastTime) / 1000);
    state.lastTime = now;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // === INPUT ===
    let input = 0;
    if(minigameKeys[pName].left.some(k => keys[k])) input -= 1;
    if(minigameKeys[pName].right.some(k => keys[k])) input += 1;

    // update angle op basis van input
    state.angle += input * 120 * dt;

    // BOOST
    if(boosts[pName]){
        state.speed += 600 * dt;
    }

    // GRAVITY / physics
    state.speed -= 400 * dt;
    state.speed *= 0.98;

    state.angle += state.speed * dt;
    state.angle = Math.max(-90, Math.min(90, state.angle));

    // === DRAW LOOP ===
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(0, 0, 120, Math.PI, 0); // halve cirkel
    ctx.stroke();

    // DRAW BALL
    const rad = state.angle * Math.PI / 180;
    ctx.fillStyle = "#ffcc00";
    ctx.beginPath();
    ctx.arc(
        Math.cos(rad)*120,
        Math.sin(rad)*120,
        10,
        0,
        Math.PI*2
    );
    ctx.fill();
    ctx.restore();

    // === CHECK SUCCESS ===
    if(state.angle >= 85){
        // minigame voltooid
        state.completed = true;
        state.active = false;
        players[pName].inMinigame = false;

        // verberg panel
        document.getElementById(
            pName === "P1" ? "panelP1" : "panelP2"
        ).style.display = "none";

        // teleport naar exit '<'
        const exit = findExitForLane(players[pName].lane);
        if (exit) {
            players[pName].x = exit.x + 0.5;
            players[pName].y = exit.y + 0.5;
        }

        // check overlay
        checkMinigameOverlay();
        return;
    }

    requestAnimationFrame(() => animateLoopingMinigame(pName));
}




 // animate BALANCE minigame

function animateBalanceMinigame(pName) {
    const canvas = mgCanvases[pName];
    const ctx = canvas.getContext("2d");
    const state = minigameState[pName];
    const now = performance.now();

    const dt = Math.min(0.05, (now - state.lastTime) / 1000);
    state.lastTime = now;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const angleRad = state.plankAngle * Math.PI / 180;

    // === INPUT ===

    let input = 0;

        // toetsenbord
    const keyset = minigameKeys[pName];
    if (keyset.left.some(k => keys[k])) input -= 1;
    if (keyset.right.some(k => keys[k])) input += 1;


    // joystick (mobile)
    const s = sticks[pName];
    input += s.x; // x is horizontaal


    //update plankhoek
    state.plankAngle += input * 120  * dt;
    state.plankAngle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, state.plankAngle));

    // === PHYSICS ===
    const gravityScale = Math.min(1.3, Math.max(0.7, GLOBAL_PLANK_LENGTH / BASE_PLANK));
    state.ballSpeed += GRAVITY * gravityScale * Math.sin(angleRad) * dt;
    state.ballSpeed *= FRICTION;
    state.ballX += state.ballSpeed * dt;

    // === BALANCE CHECK ===
    const inZone = Math.abs(state.ballX) < BALANCE_ZONE;
    if (inZone) state.balanceTime += dt;
    else state.balanceTime = 0;

    const timeLeft = Math.max(0, BALANCE_DURATION - state.balanceTime);

    if (state.balanceTime >= BALANCE_DURATION) {
      state.completed = true;
      state.active = false;
      players[pName].inMinigame = false;
      document.getElementById(pName === "P1" ? "panelP1" : "panelP2").style.display = "none";

      // âœ… Teleporteer speler naar de exit (<)
      const exit = findExitForLane(players[pName].lane);
      if (exit) {
          players[pName].x = exit.x + 0.5;
          players[pName].y = exit.y + 0.5;
      }

      checkMinigameOverlay();
      return;
    }

    // Clamp ball
    const halfPlank = GLOBAL_PLANK_LENGTH / 2;
    if (state.ballX < -halfPlank) { state.ballX = -halfPlank; state.ballSpeed = 0; }
    if (state.ballX > halfPlank) { state.ballX = halfPlank; state.ballSpeed = 0; }

    // === DRAW PLANK ===
    ctx.save();
    const pivotX = canvas.width / 2;
    const pivotY = canvas.height / 2;
    ctx.translate(pivotX, pivotY);
    ctx.rotate(angleRad);

    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(-halfPlank, 0);
    ctx.lineTo(halfPlank, 0);
    ctx.stroke();

    // === DRAW BALL OP PLANK ===
    const ballX = state.ballX;
    const ballY = 0; // op plank
    ctx.fillStyle = inZone ? "#00ff00" : "#ff8800";
    ctx.beginPath();
    ctx.arc(ballX, ballY - 14, 10, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // === DRAW COUNTDOWN ONDER DE PLANK ===
    ctx.fillStyle = "#fff";
    ctx.font = `${Math.floor(canvas.height / 6)}px monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(
        timeLeft.toFixed(1) + "s",
        canvas.width / 2,
        10 // 10px vanaf de top
    );

    requestAnimationFrame(() => animateBalanceMinigame(pName));
}











  function walkableTile(p, x, y){
    const t = tileAt(Math.floor(x), Math.floor(y));
    if(["|","G","="].includes(t)) return false;
    if(t==="1" && p.lane!=="1") return false;
    if(t==="2" && p.lane!=="2") return false;
    if(t==="H" && p.lane!=="1") return false;
    if(t==="Y" && p.lane!=="2") return false;
    return true;
  }



  // Sorteren rond track center (rechtsonder eerste)
  function checkpointCenter(group){
    let sx=0, sy=0;
    for(const t of group){ sx+=t.x+0.5; sy+=t.y+0.5; }
    return {x:sx/group.length, y:sy/group.length};
  }




 //HELPERS--------

  function findGreenFieldBounds(){
    let minX=Infinity, maxX=-Infinity;
    let minY=Infinity, maxY=-Infinity;

    for(let y=0;y<track.length;y++){
      for(let x=0;x<track[y].length;x++){
        if(track[y][x] !== "G") continue;

        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }

    return {
      x: minX * TILE_SIZE,
      y: minY * TILE_SIZE,
      width: (maxX - minX + 1) * TILE_SIZE,
      height:(maxY - minY + 1) * TILE_SIZE
    };
  }



  function updateMinigameOverlay(){
    const active =
        minigameState.P1.active ||
        minigameState.P2.active;

    minigameOverlay.style.display = active ? "block" : "none";
}


    // === Minigame panel positioning ===




    function findExitForLane(lane){
    for(let y=0;y<track.length;y++){
      for(let x=0;x<track[y].length;x++){
        if(track[y][x] !== "<") continue;

        const around = [
          tileAt(x-1,y),
          tileAt(x+1,y),
          tileAt(x,y-1),
          tileAt(x,y+1)
        ];

        if(lane === "1" && around.includes("1")) return {x,y};
        if(lane === "2" && around.includes("2")) return {x,y};
      }
    }
    return null;
}



  // === Startpositie ===
  function findStart(){
    for(let y=0;y<track.length;y++){
        for(let x=0;x<track[y].length;x++){
            if(track[y][x]!=="S") continue;
            let sXs=[], xx=x;
            while(track[y][xx]==="S"){ sXs.push(xx); xx++; }
            let spawnXs = sXs.filter(sx=> !["|","G","="].includes(tileAt(sx,y-1)));
            if(spawnXs.length>=2){
                players.P1.x = spawnXs[0]+0.5;
                players.P1.y = y-0.5;
                players.P1.started = false;
                players.P1.lap = 0;
                players.P1.finishTime = null;

                players.P2.x = spawnXs[spawnXs.length-1]+0.5;
                players.P2.y = y-0.5;
                players.P2.started = false;
                players.P2.lap = 0;
                players.P2.finishTime = null;
            }
            return;
        }
    }
}


  // === Input ===
  const keys = {};
  window.addEventListener("keydown", e=>keys[e.key.toLowerCase()]=true);
  window.addEventListener("keyup", e=>keys[e.key.toLowerCase()]=false);
  const sticks = {
  P1: { x:0, y:0 },
  P2: { x:0, y:0 }
};

function setupStick(stickId, player){
    const stick = document.getElementById(stickId);
    const knob = stick.querySelector(".knob");
    const radius = 50;

    function start(e){
        e.preventDefault();
        move(e);
        window.addEventListener("touchmove", move);
        window.addEventListener("touchend", end);
    }

    function move(e){
        if(!e.touches || e.touches.length === 0) return;
        const t = e.touches[0];
        const rect = stick.getBoundingClientRect();
        let dx = t.clientX - (rect.left + rect.width/2);
        let dy = t.clientY - (rect.top + rect.height/2);

        const len = Math.hypot(dx, dy);
        if(len > radius){
          dx = dx/len * radius;
          dy = dy/len * radius;
        }

        knob.style.transform = `translate(${dx}px, ${dy}px) translate(-50%,-50%)`;
        sticks[player].x = dx / radius;
        sticks[player].y = dy / radius;
    }

    function end(){
        sticks[player].x = 0;
        sticks[player].y = 0;
        knob.style.transform = "translate(-50%,-50%)";
        window.removeEventListener("touchmove", move);
        window.removeEventListener("touchend", end);
    }

    stick.addEventListener("touchstart", start);
}


setupStick("stickP1", "P1");
setupStick("stickP2", "P2");



  // === Update speler ===
function updatePlayer(p, dt){
    if(p.inMinigame) return;

    let ax=0, ay=0;
    for(const k in p.keys){
        if(keys[k]){
            ax += p.keys[k][0];
            ay += p.keys[k][1];
        }
    }

    const s = sticks[p === players.P1 ? "P1" : "P2"];
    ax += s.x;
    ay += s.y;

    const len = Math.hypot(ax, ay);
    if(len > 0){
        ax /= len;
        ay /= len;
        p.angle = Math.atan2(ay, ax);
    }

    const speedX = ax * SPEED * dt / TILE_SIZE;
    const speedY = ay * SPEED * dt / TILE_SIZE;

    // Bereken stappen op 0.5 tile intervallen
    const steps = Math.ceil(Math.max(Math.abs(speedX), Math.abs(speedY)) * 2);
    for (let i = 1; i <= steps; i++) {
        const nx = p.x + speedX * i / steps;
        const ny = p.y + speedY * i / steps;

        if(walkableTile(p, nx, p.y)) p.x = nx;
        if(walkableTile(p, p.x, ny)) p.y = ny;

        // Check triggers op deze tile
        checkTriggers(p, performance.now()/1000, p === players.P1 ? "P1" : "P2");
    }
}

  // === Check triggers ===

function checkTriggers(p, now, pName){
    if(p.inMinigame) return;

    const tx = Math.floor(p.x);
    const ty = Math.floor(p.y);
    let tile = tileAt(tx, ty);

    // === MINIGAME TRIGGER ===
    if(tile === ">" && p.lastTile !== tile){
        const nextTile = tileAt(tx + 1, ty); // tile achter '>'
        switch(nextTile){
            case "B": startMinigame(pName, ">B"); break;
            case "L": startMinigame(pName, ">L"); break;
            case "J": startMinigame(pName, ">J"); break;
        }
    }

    // === CHECKPOINTS ===
    const next = checkpoints[p.lane][p.nextCheckpoint];
    if(next && next.some(t => t.x === tx && t.y === ty)){
        p.nextCheckpoint++;
    }

    // === START / FINISH ===
    if(tile === "S" && p.lastTile !== "S"){
        if(!p.started){
            p.started = true;
            p.lapStart = now;
            p.lap = 0;
            p.nextCheckpoint = 0;
        } else if(p.nextCheckpoint === checkpoints[p.lane].length){
            const lapTime = now - p.lapStart;
            p.lap++;
            p.lapStart = now;
            p.nextCheckpoint = 0;
            if(!p.bestLap || lapTime < p.bestLap) p.bestLap = lapTime;

            const totalLaps = parseInt(document.getElementById("lapInput").value, 10);
            if(p.lap >= totalLaps && !p.finishTime){
                p.finishTime = now;
            }
        }
    }

    p.lastTile = tile;
}



    // ===== CHECKPOINTS =====
    const nextCheckpointGroup = checkpoints[p.lane][p.nextCheckpoint];
    if (nextCheckpointGroup && nextCheckpointGroup.some(t => t.x === tx && t.y === ty)) {
        p.nextCheckpoint++;
    }

    // ===== START / FINISH =====
    if (tile === "S" && p.lastTile !== "S") {
        if (!p.started) {
            // Eerste keer starten
            p.started = true;
            p.lapStart = now;
            p.lap = 0;
            p.nextCheckpoint = 0;
        } else if (p.nextCheckpoint === checkpoints[p.lane].length) {
            // Ronde voltooid
            const lapTime = now - p.lapStart;
            p.lap++;
            p.lapStart = now;
            p.nextCheckpoint = 0;
            if (!p.bestLap || lapTime < p.bestLap) p.bestLap = lapTime;

            const totalLaps = parseInt(document.getElementById("lapInput").value, 10);
            if (p.lap >= totalLaps && !p.finishTime) {
                p.finishTime = now;
            }
        }
    }

    // ===== Update lastTile =====
    p.lastTile = tile;
}






  // === Tekenen ===
function drawTrack() {
    for (let y = 0; y < track.length; y++) {
        for (let x = 0; x < track[y].length; x++) {
            const tile = track[y][x];
            let color;

            if (tile === "S") color = "white";       // start = wit
            else if (tile === ">") color = "#ff9900"; // trigger = geel-oranje
            else if (tile === "<") color = "#39ff14"; // exit = neon groen
            else {
                switch(tile) {
                    case "|": color = "#b30000"; break;
                    case "1": case "2": color = "#555"; break;
                    case "=": color = "#777"; break;
                    case "G": color = "green"; break;
                    case "C": color = "purple"; break;
                    case "*": case "%": color = "white"; break;
                    case "H": color = "cyan"; break;
                    case "B": color = "blue"; break;   // balance
                    case "L": color = "red"; break;    // looping
                    case "J": color = "purple"; break; // jump
                    default: color = "#777";
                }
            }

            ctx.fillStyle = color;
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
    }
}

function drawPlayers() {
    for (const [key, p] of Object.entries(players)) {
        const sprite = carSprites[key];
        if (!sprite.complete) continue;

        const size = TILE_SIZE * 2; // grootte auto

        ctx.save();
        ctx.translate(p.x * TILE_SIZE, p.y * TILE_SIZE);

        // Correctie voor top-down sprite: voorkant wijst omhoog
        ctx.rotate(p.angle - Math.PI/2);

        ctx.drawImage(sprite, -size / 2, -size / 2, size, size);
        ctx.restore();
    }
}


  function fmt(t){ return t!=null?t.toFixed(2)+"s":"--"; }






function drawHUD() {
    const laps = +document.getElementById("lapInput").value;
    const now = performance.now() / 1000;

    const p1CurrentLap = players.P1.started ? (now - players.P1.lapStart) : 0;
    const p2CurrentLap = players.P2.started ? (now - players.P2.lapStart) : 0;

    // Alleen de spans updaten, input blijft intact
    document.getElementById("statsP1").textContent =
        `Lap ${players.P1.lap}/${laps} | Current: ${fmt(p1CurrentLap)} | Best: ${fmt(players.P1.bestLap)} | Total: ${fmt(players.P1.totalTime)}`;

    document.getElementById("statsP2").textContent =
        `Lap ${players.P2.lap}/${laps} | Current: ${fmt(p2CurrentLap)} | Best: ${fmt(players.P2.bestLap)} | Total: ${fmt(players.P2.totalTime)}`;
}

  // === Loop ===
let lastTime = performance.now();
let frameCount = 0;




function loop(now){
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    if(!gameOver){

        // === Update spelers (pauzeert automatisch in minigame) ===
        updatePlayer(players.P1, dt);
        updatePlayer(players.P2, dt);

        const currentTime = performance.now() / 1000;

        // === Check triggers ===
        checkTriggers(players.P1, currentTime, "P1");
        checkTriggers(players.P2, currentTime, "P2");

        // === Update totale tijd (niet in minigame) ===
       if(players.P1.started) {
    players.P1.totalTime += dt;
}
if(players.P2.started) {
    players.P2.totalTime += dt;
}

        // === Tekenen ===
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTrack();
        drawPlayers();
        drawHUD();

        // === Finish check (niet elke frame) ===
        frameCount++;
        if(frameCount >= 20){
            frameCount = 0;

            // spelers die gefinisht zijn
            const finishedPlayers = Object.entries(players)
                .filter(([_, p]) => p.finishTime != null);

            if(finishedPlayers.length > 0){
    // laagste finishTime wint
    finishedPlayers.sort((a, b) =>
        a[1].finishTime - b[1].finishTime
    );

    const winnerKey = finishedPlayers[0][0]; // "P1" of "P2"

const winnerName =
    document.getElementById(
        winnerKey === "P1" ? "nameP1" : "nameP2"
    ).value || winnerKey;

gameOver = true;
document.getElementById("winnerText").textContent =
    winnerName + " WINS!";
document.getElementById("overlay").style.display = "flex";

    // âœ… Upload hier de best_lap voor iedere speler die toch een ronde gereden heeft
        // Upload scores naar Supabase
    uploadEndScores();
}
        }
    }

    requestAnimationFrame(loop);
}




  </script>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const supabaseUrl = 'https://itmhwyamdcdcompixnrk.supabase.co'
const supabaseKey = 'sb_publishable_lun6Mhjl_0P4vqQNaPGyKw_OKNwJ9cW'
const supabase = createClient(supabaseUrl, supabaseKey)

window.uploadScore = function(playerName, bestLap) {
    if (!playerName || bestLap == null) return;
    supabase.from(currentTable).insert([{player_name: playerName, lap_time: bestLap}])
        .then(({data, error}) => {
            if(error) console.error('Supabase error:', error)
            else console.log(`Score uploaded to ${currentTable}:`, data)
        });
}


window.uploadEndScores = function() {
    if(players.P1.lap > 0) uploadScore(document.getElementById("nameP1").value, players.P1.bestLap)
    if(players.P2.lap > 0) uploadScore(document.getElementById("nameP2").value, players.P2.bestLap)
}
</script>


<script>
/* === PLAYER NAME PERSISTENCE === */

const nameInputP1 = document.getElementById("nameP1");
const nameInputP2 = document.getElementById("nameP2");
const lapInput = document.getElementById("lapInput");
// Load saved names
const savedP1 = localStorage.getItem("circuitracer_name_p1");
const savedP2 = localStorage.getItem("circuitracer_name_p2");
const savedLaps = localStorage.getItem("circuitracer_laps");

if (savedP1) nameInputP1.value = savedP1;
if (savedP2) nameInputP2.value = savedP2;

// Save on change
nameInputP1.addEventListener("input", () => {
    localStorage.setItem("circuitracer_name_p1", nameInputP1.value);
});

nameInputP2.addEventListener("input", () => {
    localStorage.setItem("circuitracer_name_p2", nameInputP2.value);
});

lapInput.addEventListener("change", () => {
    let value = parseInt(lapInput.value, 10);

    if (isNaN(value) || value < 1) value = 1;
    if (value > 99) value = 99;

    lapInput.value = value;
    localStorage.setItem("circuitracer_laps", value);
});


</script>

</body>
  </html>
