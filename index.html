  <!DOCTYPE html>
  <html lang="nl">
  <head>
  <meta charset="UTF-8">
  <title>Circuit Racer V1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<style>
body {
    margin:0;
    background:#111;
    color:white;
    font-family:monospace;
    display:flex;
    flex-direction:column;
    align-items:center;
    touch-action: none;
}

html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
}


h2 { display: none !important; }
/* ===== TOP BAR (NEEMT RUIMTE IN, LIGT NIET OVER CANVAS) ===== */
#topBar {
    width: 100%;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(0,0,0,0.85);
    border-bottom: 2px solid #333;
    padding: 0 10px;
    box-sizing: border-box;
    z-index: 30;
}

/* laps links */
#lapContainer {
    background: none;
    border: none;
    padding: 0;
    font-size: 14px;
}

/* HUD gecentreerd */
#hud {
    font-size: 14px;
    text-align: center;
    line-height: 1.2;
}

/* ===== GAME AREA ===== */


canvas#game {
    max-width: 100%;
    max-height: 100%;
    image-rendering: pixelated;
}

#mobileControls {
    position: fixed;
    bottom: 5px;
    left: 0;
    right: 0;
    height: 35%;
    pointer-events: auto;
    display: flex;
    justify-content: space-between;
    padding: 0 15px;
    box-sizing: border-box;
    z-index: 12;
}

.stick {
    position: relative;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.12);
    pointer-events: auto;
    touch-action: none;
}

#stickP1 { margin-left: 10px; }
#stickP2 { margin-right: 10px; }

.knob {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.7);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}


#minigameOverlay {
    position: fixed;
    top: 0;              /* ðŸ‘ˆ BELANGRIJK */
    left: 0;
    right: 0;
    bottom: 0;
    display: none;
    pointer-events: none;
    z-index: 25;
}


.minigamePanel {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: rgba(0,0,0,0.75);
    border: 2px solid white;
    padding: 6px;
    pointer-events: auto;
    min-width: 20px;
    min-height: 80px;
    width: 100%; /* default */
    height: auto; /* default */
    max-height: 40%;
    display: none;
    box-sizing: border-box;
}


#scoreboardButtonContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 10px; /* beetje ruimte tussen lap counter en HUD */
}
  
.scoreboardButton {
    display: inline-block;
    padding: 8px 15px;
    font-size: 1.2rem; /* kleiner dan game-knop, past beter */
    font-weight: bold;
    color: #ffcc00;             /* gele letters */
    background-color: red;  /* rood */
    border: 2px solid #ffff66;
    border-radius: 8px;
    text-decoration: none;
    box-shadow: 0 0 15px #ffff66;
    transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
}

.scoreboardButton:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px #ffff66;
    background-color: green; /* groen bij hover */
}

  .scoreboardButton:active {
    transform: scale(1.1);
    box-shadow: 0 0 20px #ffff66;
    background-color: green; /* groen bij hover */
}

/* Responsive tweaks */
@media(max-width:900px){
  .scoreboardButton {
    font-size: 1rem;
    padding: 6px 12px;
  }
}


/* Overlay einde spel */
#overlay {
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:rgba(0,0,0,0.85);
    color:white;
    font-size:48px;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    z-index:30;
    gap:20px;
}
#gameWrapper {
    position: relative;
    width: 100%;
    height: calc(100vh - 48px);
    max-height: calc(100vh - 48px);

    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

#game {
    max-width: 100%;
    max-height: 100%;
    image-rendering: pixelated;
}

#newGameBtn {
    font-size:24px;
    padding:10px 20px;
    cursor:pointer;
}

@media (orientation: portrait) {
  body::before {
    content: "Draai je telefoon horizontaal";
    position: fixed;
    inset: 0;
    background: black;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 999;
    font-size: 20px;
  }
}

/* Mobile tweaks (landscape) */
@media (max-width: 900px) {
  #gameWrapper {
    height: calc(100vh - 40px);
  }

  #mobileControls {
    padding-bottom: env(safe-area-inset-bottom);
    height: 40%;
  }
}

</style>


  </head>
<body>

<div id="topBar">
  <!-- Laps links -->
  <div id="lapContainer">
    Laps:
    <input id="lapInput" type="number" value="3" min="3" style="width:50px">
  </div>

    <!-- SCOREBOARD knop midden -->
  <div id="scoreboardButtonContainer">
    <a href="https://blackeagle8100.github.io/RacingBoard/" target="_blank" class="scoreboardButton">SCOREBOARD!</a>
  </div>
  

 <!-- HUD gecentreerd -->
  <div id="hud">
    <input type="text" id="nameP1" value="P1" style="width:60px">
    <span id="statsP1"></span><br>
    <input type="text" id="nameP2" value="P2" style="width:60px">
    <span id="statsP2"></span>
  </div>
</div>


  </div>


  <div id="gameWrapper">
  <canvas id="game"></canvas>
</div>


    <div id="minigameOverlay">
      <div id="panelP1" class="minigamePanel">
        <div>Player 1</div>
        <canvas id="minigameCanvas1" width="300" height="150"></canvas>
        <div id="minigameStatus1"></div>
      </div>

      <div id="panelP2" class="minigamePanel">
        <div>Player 2</div>
        <canvas id="minigameCanvas2" width="300" height="150"></canvas>
        <div id="minigameStatus2"></div>
      </div>
    </div>

    <div id="overlay" style="display:none">
      <span id="winnerText">WINNER</span>
      <button id="newGameBtn">NEW GAME</button>
    </div>


  <div id="mobileControls">
    <div id="stickP1" class="stick"><div class="knob"></div></div>
    <div id="stickP2" class="stick"><div class="knob"></div></div>
  </div>




  <script>
  // Supabase client initialiseren


    // Minigame instellingen
  // === MINIGAME SETTINGS ===
  // === MINIGAME SETTINGS ===
  const BALANCE_DURATION = 5; // seconden dat de speler moet balanceren
  let PLANK_LENGTH = 300;  // pixels
  const MAX_ANGLE = 35;       // max kanteling
  const BALANCE_ZONE = 30;    // px rond midden waar het groen is
  const GRAVITY = 700;        // pixels/sec^2


  // key mapping
  const minigameKeys = {
    P1: { left: "q", right: "d" },
    P2: { left: "j", right: "l" }
  };

  const minigameOverlay = document.getElementById("minigameOverlay");

  const mgCanvases = {
    P1: document.getElementById("minigameCanvas1"),
    P2: document.getElementById("minigameCanvas2")
  };
  const mgCtxs = {
    P1: mgCanvases.P1.getContext("2d"),
    P2: mgCanvases.P2.getContext("2d")
  };
  const mgStatus = {
    P1: document.getElementById("minigameStatus1"),
    P2: document.getElementById("minigameStatus2")
  };

  // Track minigame state per speler
  const minigameState = {
    P1: {active:false, plankAngle:0, balanceTime:0, completed:false, lastTime:0},
    P2: {active:false, plankAngle:0, balanceTime:0, completed:false, lastTime:0}
  };

  //GAMESETTINGS
  const TILE_SIZE = 16;
  const SPEED = 400;
  document.getElementById("newGameBtn").addEventListener("click", () => {
    location.reload();
  });
  const track = [
  "**||*||**||**||**||**||**||**||**||**||**||**||**||**",
  "*11111C111111111NNNNNY222>BBBBBOBBBBB<22222C22222222*",
  "|11111C111111111NNNNNY222>BBBBBOBBBBB<22222C22222222|",
  "|11=============NNNN==============================22|",
  "*11=22C222222222NNNNNH111>BBBBBOBBBBB<11111C11111=22*",
  "*11=22C222222222NNNNNH111>BBBBBOBBBBB<11111C11111=22*",
  "|11=22||**||**||**||**||**||**||**||**||**||***11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=22*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*%%=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=%%*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*%%=22|",
  "*11=22|GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG*11=%%*",
  "*11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22*",
  "|11=22*GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG|11=22|",
  "|11=22***||**||**||**||**||**||**||**||**||**||SSSSS|",
  "*11=222222C222222222222222222YNNNNN1111111111C111=22*",
  "*11=222222C222222222222222222YNNNNN1111111111C111=22*",
  "|11============================NNNN===============22|",
  "|111111111C111111111111111111HNNNNN2222222222C222222|",
  "*111111111C111111111111111111HNNNNN2222222222C222222*",
  "**||**||**||**||**||**||**||**||**||**||**||**||*||**"
  ];

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  let gameOver = false;



function positionMinigamePanel(pName){
    const panel = document.getElementById(pName === "P1" ? "panelP1" : "panelP2");
    const canvasRect = canvas.getBoundingClientRect();
    const green = findGreenFieldBounds();

    const scaleX = canvasRect.width / canvas.width;
    const scaleY = canvasRect.height / canvas.height;

    // Panel grootte
    const PANEL_W = Math.min(500, green.width * scaleX * 0.45); // 45% van groen
    let PANEL_H = Math.min(350, green.height * scaleY * 0.6); // 60% van groen
if(window.innerHeight < 600) PANEL_H = Math.min(300, green.height * scaleY * 0.7); // extra voor small screens


    panel.style.width  = PANEL_W + "px";
    panel.style.height = PANEL_H + "px";

    const greenLeft = canvasRect.left + green.x * scaleX;
    const TOPBAR_HEIGHT = 48;

    const greenTop = canvasRect.top + green.y * scaleY;

// Verticaal centreren in het groene veld
panel.style.top = greenTop + green.height * scaleY / 2 - PANEL_H / 2 + "px";


    // Plaats P1 links van het midden van groen, P2 rechts van het midden
    if(pName === "P1"){
        panel.style.left = greenLeft + green.width * scaleX * 0.25 - PANEL_W/2 + "px";
    } else {
        panel.style.left = greenLeft + green.width * scaleX * 0.75 - PANEL_W/2 + "px";
    }

    // Verticaal centreren in het groene veld
    panel.style.top = greenTop + green.height * scaleY / 2 - PANEL_H/2 + "px";

    resizeMinigameCanvas(pName);
}

function resizeMinigameCanvas(p){
    const panel = document.getElementById(p === "P1" ? "panelP1" : "panelP2");
    const canvas = mgCanvases[p];

    canvas.width  = panel.clientWidth - 12;
    canvas.height = panel.clientHeight - 20; // iets hoger

    PLANK_LENGTH = Math.min(canvas.width * 0.9, 300);
}



function resizeCanvas(){
  const gameWidth  = track[0].length * TILE_SIZE;
  const gameHeight = track.length * TILE_SIZE;

  canvas.width  = gameWidth;
  canvas.height = gameHeight;

  const vw = window.innerWidth;
  const wrapper = document.getElementById("gameWrapper");
  const vh = wrapper.clientHeight;

  const scale = Math.min(vw / gameWidth, vh / gameHeight);

  canvas.style.width  = (gameWidth  * scale) + "px";
  canvas.style.height = (gameHeight * scale) + "px";

  positionMinigamePanel("P1");
  positionMinigamePanel("P2");

}


 window.addEventListener("orientationchange", resizeCanvas);
 window.addEventListener("resize", resizeCanvas);
  resizeCanvas();



  function tileAt(tx, ty){ return track[ty]?.[tx] || "|"; }


    // Start minigame voor speler p (P1 of P2)

function startMinigame(pName){
    const state = minigameState[pName];
    if(state.active) return;

    state.active = true;
    updateMinigameOverlay();

    state.plankAngle = 0;
    state.ballX = -PLANK_LENGTH/2 + 10;
    state.ballSpeed = 0;
    state.balanceTime = 0;
    state.completed = false;
    state.lastTime = performance.now()/1000;

    players[pName].inMinigame = true;

    const panel = document.getElementById(
        pName === "P1" ? "panelP1" : "panelP2"
    );

    panel.style.display = "flex";
    panel.style.pointerEvents = "auto";

    positionMinigamePanel(pName);

    requestAnimationFrame(() => animateMinigame(pName));
}





function checkMinigameOverlay(){
    if(!minigameState.P1.active && !minigameState.P2.active){
        minigameOverlay.style.display = "none";
    }
}

  // Minigame animatie per speler




 // animate minigame


function animateMinigame(pName){
    const state = minigameState[pName];
    if(!state.active) return;

    const tNow = performance.now() / 1000;
    const dt = tNow - state.lastTime;
    state.lastTime = tNow;

    // === INPUT ===
    const stick = sticks[pName];
    const DEADZONE = 0.25;

    let left =
        keys[minigameKeys[pName].left] ||
        (stick && stick.x < -DEADZONE);

    let right =
        keys[minigameKeys[pName].right] ||
        (stick && stick.x > DEADZONE);

    // === PLANK CONTROLE ===
    let stickForce = 0;

    if (stick) {
        stickForce = stick.x;
    
        // deadzone toepassen
        if (Math.abs(stickForce) < DEADZONE) {
            stickForce = 0;
        } else {
            // her-schaal zodat hij na deadzone vloeiend begint
            stickForce =
                (Math.abs(stickForce) - DEADZONE) / (1 - DEADZONE)
                * Math.sign(stickForce);
        }
    }
        
    // rotatie
    state.plankAngle += stickForce * 35 * dt;


    const angleRad = state.plankAngle * Math.PI / 180;

    // === PHYSICS ===
    state.ballSpeed += GRAVITY * Math.sin(angleRad) * dt;
    state.ballSpeed *= 0.995;
    state.ballX += state.ballSpeed * dt;

    // === PLANK RAND ===
    const LIMIT = PLANK_LENGTH / 2 - 10;
    if(state.ballX > LIMIT){
        state.ballX = LIMIT;
        state.ballSpeed *= -0.3;
    }
    if(state.ballX < -LIMIT){
        state.ballX = -LIMIT;
        state.ballSpeed *= -0.3;
    }

    // === BALANCE CHECK ===
    let ballColor = "orange";

    if(Math.abs(state.ballX) < BALANCE_ZONE){
        state.balanceTime += dt;
        ballColor = "green";

        if(state.balanceTime >= BALANCE_DURATION){
            state.completed = true;
        }
    } else {
        state.balanceTime = 0;
    }

    // === STATUS TEXT ===
    mgStatus[pName].textContent = state.completed
        ? "Houd rechts om te verlaten"
        : `Balanceren: ${(BALANCE_DURATION - state.balanceTime).toFixed(1)}s`;

    // === DRAW ===
    drawMinigame(pName, ballColor);

    // === EXIT ===
    if(state.completed && right){
        const exit = findExitForLane(players[pName].lane);
        if(exit){
            players[pName].x = exit.x + 0.5;
            players[pName].y = exit.y + 0.5;
        }

        state.active = false;
        players[pName].inMinigame = false;
        players[pName].lastTile = null;

        const panel = document.getElementById(
            pName === "P1" ? "panelP1" : "panelP2"
        );
        panel.style.display = "none";
        panel.style.pointerEvents = "none";

        updateMinigameOverlay();
        return;
    }

    requestAnimationFrame(() => animateMinigame(pName));
}






 //drawminigame
function drawMinigame(pName, ballColor){
  const canvas = mgCanvases[pName];
  const ctx = mgCtxs[pName];
  const state = minigameState[pName];

  ctx.clearRect(0,0,canvas.width,canvas.height);
  const pivotX = canvas.width/2;
  const pivotY = canvas.height/2;

  // plank tekenen
  ctx.save();
  ctx.translate(pivotX, pivotY);
  ctx.rotate(state.plankAngle * Math.PI/180);
  ctx.fillStyle = "#aaa";
  ctx.fillRect(-PLANK_LENGTH/2, -5, PLANK_LENGTH, 10);
  ctx.restore();

  // balpositie exact op plank
  const angleRad = state.plankAngle * Math.PI / 180;
  const ballWorldX = pivotX + state.ballX * Math.cos(angleRad);
  const ballWorldY = pivotY + state.ballX * Math.sin(angleRad) - 10;

  // bal tekenen
  ctx.beginPath();
  ctx.arc(ballWorldX, ballWorldY, 10, 0, Math.PI*2);
  ctx.fillStyle = ballColor;
  ctx.fill();
}





  function walkableTile(p, x, y){
    const t = tileAt(Math.floor(x), Math.floor(y));
    if(["|","G","="].includes(t)) return false;
    if(t==="1" && p.lane!=="1") return false;
    if(t==="2" && p.lane!=="2") return false;
    if(t==="H" && p.lane!=="1") return false;
    if(t==="Y" && p.lane!=="2") return false;
    return true;
  }

  // === Checkpoints opbouwen ===
  const checkpoints = { "1": [], "2": [] };
  const used = new Set();

  for(let y=0;y<track.length;y++){
    for(let x=0;x<track[y].length;x++){
      if(track[y][x]!=="C") continue;
      const key = x+","+y;
      if(used.has(key)) continue;

      const tiles = [{x,y}];
      if(track[y+1]?.[x]==="C"){ tiles.push({x,y:y+1}); used.add(x+","+(y+1)); }

      const around = [tileAt(x-1,y), tileAt(x+1,y), tileAt(x,y-1), tileAt(x,y+1)];
      const lane = around.includes("1") ? "1" : "2";
      checkpoints[lane].push(tiles);
      used.add(key);
    }
  }

  // Sorteren rond track center (rechtsonder eerste)
  function checkpointCenter(group){
    let sx=0, sy=0;
    for(const t of group){ sx+=t.x+0.5; sy+=t.y+0.5; }
    return {x:sx/group.length, y:sy/group.length};
  }
  const trackCenter = {x: track[0].length/2, y: track.length/2};

  for(const lane of ["1","2"]){
    checkpoints[lane].sort((a,b)=>{
      const ca=checkpointCenter(a), cb=checkpointCenter(b);
      return Math.atan2(ca.y-trackCenter.y, ca.x-trackCenter.x)
          - Math.atan2(cb.y-trackCenter.y, cb.x-trackCenter.x);
    });
    while(true){
      const c = checkpointCenter(checkpoints[lane][0]);
      if(c.x>trackCenter.x && c.y>trackCenter.y) break;
      checkpoints[lane].push(checkpoints[lane].shift());
    }
  }

  // === Spelers ===
const players = {
  P1: {
    lane:"1", x:0,y:0,color:"cyan",
    keys:{z:[0,-1],s:[0,1],q:[-1,0],d:[1,0]},
    started:false, lap:0, lapStart:0,
    totalTime:0, bestLap:null,
    lastTile:null, nextCheckpoint:0,
    inMinigame:false,
    finishTime: null      // ðŸ‘ˆ TOEVOEGEN
  },
  P2: {
    lane:"2", x:0,y:0,color:"yellow",
    keys:{i:[0,-1],k:[0,1],j:[-1,0],l:[1,0]},
    started:false, lap:0, lapStart:0,
    totalTime:0, bestLap:null,
    lastTile:null, nextCheckpoint:0,
    inMinigame:false,
    finishTime: null      // ðŸ‘ˆ TOEVOEGEN
  }
}

 //HELPERS--------

  function findGreenFieldBounds(){
    let minX=Infinity, maxX=-Infinity;
    let minY=Infinity, maxY=-Infinity;

    for(let y=0;y<track.length;y++){
      for(let x=0;x<track[y].length;x++){
        if(track[y][x] !== "G") continue;

        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }

    return {
      x: minX * TILE_SIZE,
      y: minY * TILE_SIZE,
      width: (maxX - minX + 1) * TILE_SIZE,
      height:(maxY - minY + 1) * TILE_SIZE
    };
  }



  function updateMinigameOverlay(){
    const active =
        minigameState.P1.active ||
        minigameState.P2.active;

    minigameOverlay.style.display = active ? "block" : "none";
}


    // === Minigame panel positioning ===



  function findExitForLane(lane){
    for(let y=0;y<track.length;y++){
      for(let x=0;x<track[y].length;x++){
        if(track[y][x] !== "<") continue;

        const around = [
          tileAt(x-1,y),
          tileAt(x+1,y),
          tileAt(x,y-1),
          tileAt(x,y+1)
        ];

        if(lane === "1" && around.includes("1")) return {x,y};
        if(lane === "2" && around.includes("2")) return {x,y};
      }
    }
    return null;
  }
  // === Startpositie ===
  function findStart(){
    for(let y=0;y<track.length;y++){
        for(let x=0;x<track[y].length;x++){
            if(track[y][x]!=="S") continue;
            let sXs=[], xx=x;
            while(track[y][xx]==="S"){ sXs.push(xx); xx++; }
            let spawnXs = sXs.filter(sx=> !["|","G","="].includes(tileAt(sx,y-1)));
            if(spawnXs.length>=2){
                players.P1.x = spawnXs[0]+0.5;
                players.P1.y = y-0.5;
                players.P1.started = false;
                players.P1.lap = 0;
                players.P1.finishTime = null;

                players.P2.x = spawnXs[spawnXs.length-1]+0.5;
                players.P2.y = y-0.5;
                players.P2.started = false;
                players.P2.lap = 0;
                players.P2.finishTime = null;
            }
            return;
        }
    }
}

  findStart();

  // === Input ===
  const keys = {};
  window.addEventListener("keydown", e=>keys[e.key.toLowerCase()]=true);
  window.addEventListener("keyup", e=>keys[e.key.toLowerCase()]=false);
  const sticks = {
  P1: { x:0, y:0 },
  P2: { x:0, y:0 }
};

function setupStick(stickId, player){
    const stick = document.getElementById(stickId);
    const knob = stick.querySelector(".knob");
    const radius = 50;

    function start(e){
        e.preventDefault();
        move(e);
        window.addEventListener("touchmove", move);
        window.addEventListener("touchend", end);
    }

    function move(e){
        const t = e.touches[0];
        const rect = stick.getBoundingClientRect();
        let dx = t.clientX - (rect.left + rect.width/2);
        let dy = t.clientY - (rect.top + rect.height/2);

        const len = Math.hypot(dx, dy);
        if(len > radius){
          dx = dx/len * radius;
          dy = dy/len * radius;
        }

        knob.style.transform = `translate(${dx}px, ${dy}px) translate(-50%,-50%)`;
        sticks[player].x = dx / radius;
        sticks[player].y = dy / radius;
    }

    function end(){
        sticks[player].x = 0;
        sticks[player].y = 0;
        knob.style.transform = "translate(-50%,-50%)";
        window.removeEventListener("touchmove", move);
        window.removeEventListener("touchend", end);
    }

    stick.addEventListener("touchstart", start);
}


setupStick("stickP1", "P1");
setupStick("stickP2", "P2");
  // === Update speler ===
  function updatePlayer(p, dt){
    if(p.inMinigame) return; // â›” pauzeer speler

    let ax=0, ay=0;
    for(const k in p.keys){
      if(keys[k]){
        ax+=p.keys[k][0];
        ay+=p.keys[k][1];
      }
    }

    const s = sticks[p === players.P1 ? "P1" : "P2"];
    ax += s.x;
    ay += s.y;
        const len=Math.hypot(ax,ay);
    if(len>0){ ax/=len; ay/=len; }

    const nx = p.x + ax*SPEED*dt/TILE_SIZE;
    const ny = p.y + ay*SPEED*dt/TILE_SIZE;

    if(walkableTile(p,nx,p.y)) p.x=nx;
    if(walkableTile(p,p.x,ny)) p.y=ny;
  }

  // === Check triggers ===
function checkTriggers(p, now, pName){
    if(p.inMinigame) return;

    const tx = Math.floor(p.x);
    const ty = Math.floor(p.y);
    const tile = tileAt(tx, ty);

    // === MINIGAME TRIGGER (EERST!) ===
    if(tile === ">" && p.lastTile !== ">" && !p.inMinigame){
        startMinigame(pName);
    }

    // === CHECKPOINTS ===
    const next = checkpoints[p.lane][p.nextCheckpoint];
    if(next && next.some(t => t.x === tx && t.y === ty)){
        p.nextCheckpoint++;
    }

    // === START / FINISH ===
    if(tile === "S" && p.lastTile !== "S"){
        if(!p.started){
            p.started = true;
            p.lapStart = now;
            p.lap = 0;
            p.nextCheckpoint = 0;
        } else if(p.nextCheckpoint === checkpoints[p.lane].length){
            const lapTime = now - p.lapStart;
            p.lap++;
            p.lapStart = now;
            p.nextCheckpoint = 0;
            if(!p.bestLap || lapTime < p.bestLap) p.bestLap = lapTime;

            const totalLaps = +document.getElementById("lapInput").value;
            if(p.lap >= totalLaps && !p.finishTime){
                p.finishTime = now;
            }
        }
    }

    p.lastTile = tile;
}





  // === Tekenen ===
  function drawTrack(){
    for(let y=0;y<track.length;y++){
      for(let x=0;x<track[y].length;x++){
        switch(track[y][x]){
          case "|": ctx.fillStyle="#b30000"; break;
          case "1": case "2": ctx.fillStyle="#555"; break;
          case "=": ctx.fillStyle="#777"; break;
          case "G": ctx.fillStyle="green"; break;
          case "C":
            let active=false;
            for(const p of Object.values(players)){
              const cp = checkpoints[p.lane][p.nextCheckpoint];
              if(cp && cp.some(t=>t.x===x && t.y===y)){ active=true; break; }
            }
            ctx.fillStyle=active?"green":"purple";
            break;
          case "S": ctx.fillStyle="white"; break;
          case "*": case "%": ctx.fillStyle="white"; break;
          case ">": case "<": case "O": ctx.fillStyle="orange"; break;
          case "N": ctx.fillStyle="#000"; break;
          case "Y": ctx.fillStyle="yellow"; break;
          case "H": ctx.fillStyle="cyan"; break;
          case "B": ctx.fillStyle="#999"; break;
          default: ctx.fillStyle="#777";
        }
        ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      }
    }
  }
  function drawPlayers(){
    for(const p of Object.values(players)){
      ctx.fillStyle=p.color;
      ctx.beginPath();
      ctx.arc(p.x*TILE_SIZE, p.y*TILE_SIZE, TILE_SIZE*0.4,0,Math.PI*2);
      ctx.fill();
    }
  }
  function fmt(t){ return t!=null?t.toFixed(2)+"s":"--"; }






function drawHUD() {
    const laps = +document.getElementById("lapInput").value;
    const now = performance.now() / 1000;

    const p1CurrentLap = players.P1.started ? (now - players.P1.lapStart) : 0;
    const p2CurrentLap = players.P2.started ? (now - players.P2.lapStart) : 0;

    // Alleen de spans updaten, input blijft intact
    document.getElementById("statsP1").textContent =
        `Lap ${players.P1.lap}/${laps} | Current: ${fmt(p1CurrentLap)} | Best: ${fmt(players.P1.bestLap)} | Total: ${fmt(players.P1.totalTime)}`;

    document.getElementById("statsP2").textContent =
        `Lap ${players.P2.lap}/${laps} | Current: ${fmt(p2CurrentLap)} | Best: ${fmt(players.P2.bestLap)} | Total: ${fmt(players.P2.totalTime)}`;
}

  // === Loop ===
let lastTime = performance.now();
let frameCount = 0;


  function uploadEndScores() {
      if(players.P1.lap > 0) uploadScore(document.getElementById("nameP1").value, players.P1.bestLap)
      if(players.P2.lap > 0) uploadScore(document.getElementById("nameP2").value, players.P2.bestLap)
  }

function loop(now){
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    if(!gameOver){

        // === Update spelers (pauzeert automatisch in minigame) ===
        updatePlayer(players.P1, dt);
        updatePlayer(players.P2, dt);

        const currentTime = performance.now() / 1000;

        // === Check triggers ===
        checkTriggers(players.P1, currentTime, "P1");
        checkTriggers(players.P2, currentTime, "P2");

        // === Update totale tijd (niet in minigame) ===
       if(players.P1.started) {
    players.P1.totalTime += dt;
}
if(players.P2.started) {
    players.P2.totalTime += dt;
}

        // === Tekenen ===
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTrack();
        drawPlayers();
        drawHUD();

        // === Finish check (niet elke frame) ===
        frameCount++;
        if(frameCount >= 20){
            frameCount = 0;

            // spelers die gefinisht zijn
            const finishedPlayers = Object.entries(players)
                .filter(([_, p]) => p.finishTime != null);

            if(finishedPlayers.length > 0){
    // laagste finishTime wint
    finishedPlayers.sort((a, b) =>
        a[1].finishTime - b[1].finishTime
    );

    const winner = finishedPlayers[0][0];

    gameOver = true;
    document.getElementById("winnerText").textContent =
        winner + " WINS!";
    document.getElementById("overlay").style.display = "flex";

    // âœ… Upload hier de best_lap voor iedere speler die toch een ronde gereden heeft
        // Upload scores naar Supabase
    uploadEndScores();
}
        }
    }

    requestAnimationFrame(loop);
}


requestAnimationFrame(loop);
// Verberg mobile controls op apparaten zonder touch
const hasTouch =
  ("ontouchstart" in window) || navigator.maxTouchPoints > 0;

if (!hasTouch) {
  document.getElementById("mobileControls").style.display = "none";
}
  </script>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const supabaseUrl = 'https://itmhwyamdcdcompixnrk.supabase.co'
const supabaseKey = 'sb_publishable_lun6Mhjl_0P4vqQNaPGyKw_OKNwJ9cW'
const supabase = createClient(supabaseUrl, supabaseKey)

window.uploadScore = function(playerName, bestLap) {
    if (!playerName || bestLap == null) return
    supabase.from('scores').insert([{player_name: playerName, lap_time: bestLap}])
        .then(({data, error}) => {
            if(error) console.error('Supabase error:', error)
            else console.log('Score uploaded:', data)
        })
}

window.uploadEndScores = function() {
    if(players.P1.lap > 0) uploadScore(document.getElementById("nameP1").value, players.P1.bestLap)
    if(players.P2.lap > 0) uploadScore(document.getElementById("nameP2").value, players.P2.bestLap)
}
</script>


</body>
  </html>
